# 并查集
并查集主要用于解决一些**元素分组**的问题。

## 简单例子
并查集的重要思想在于，用集合中的一个元素代表集合。两个元素间存在关系，以一个元素作为根节点，另一个元素作为其子节点。

如亲戚关系：A 与 B 和 C 都是亲戚。那么使用并查集表示如下：
```
A  
|- B
|- C   
```
这个家族由元素 A 作为代表，若此时来了 D ，B 与 D 是亲戚，通过 B 一直往上寻根，查询到该家族的代表是 A ，将 D 作为 A 的子节点（表示 D 是 A 家族中的人），那么可以表示如下
```
A  
|- B
|- C
|- D
```
查询两个人是否是亲戚时，仅需要一直往上寻根，判断他们所在家族的根节点是不是同一个人即可。

## 算法实现

从上述例子可以看出，并查集主要用于管理一系列不相交的集合，并支持两种操作：

- 合并（Union）：把两个不相交的集合合并为一个集合。
- 查询（Find）：查询两个元素是否在同一个集合中。
- 
1. 初始化
```
let tot = 1000 // 表示有 1000 个元素
var f = [Int](repeating: 0, count: tot)
// 起始时将各个元素的代表任务设置为自身
for i in 0..<tot {
    f[i] = i
}
```

2. 合并
```
func union(_ f: inout [Int], _ x: Int, _ y: Int) {
    let fx = find(&f, x)    // 找到 x 的根节点
    let fy = find(&f, y)    // 找到 y 的根节点
    f[fx] = fy              // 将 x 的根节点设置为 y 的根节点
}
```
3. 查询，其中的「路径压缩」见参考文献说明
```
func find(_ f: inout [Int], _ x: Int) -> Int {
    if x == f[x] {
        return x    // 根节点
    }
    f[x] = find(&f, f[x]) // 路径压缩
    return f[x]     // 返回根节点
}
```

## 参考
1. [算法学习笔记(1) : 并查集](https://zhuanlan.zhihu.com/p/93647900/)
