# 链表
链表与数组相似，它是由多个节点连接而成。

## 链表节点一般表示
``` swift
public class ListNode {
    public var val: Int
    public var next: ListNode?
    public init(_ val: Int) {
        self.val = val
        self.next = nil
    }
}
```

## 时间复杂度
链表节点的取值、插入、删除的时间复杂度为：
1. 取值：`O(n)` ，由于从表头开始，一个个进行遍历
2. 插入：`O(1)`，这里仅表示插入这一步骤的时间复杂度，仅需要将待插入的节点的 `next` 指针指向插入位置的下一个节点，同时自身成为插入位置的上一个节点的`next`
3. 删除：`O(1)`，将待删除节点的父节点的 `next` 指向自己的 `next` 

## 如何判断链表中是否有环
要求得链表中是否有环，有两种方法：
1. 使用 hash 表记录经过的点，若重复访问到，则证明有环，时间复杂度和空间复杂度都是`O(n)`
2. Floyd 判圈算法（龟兔赛跑算法）：定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。
   初始时，慢指针在位置 head，而快指针在位置 `head.next`。
   这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。时间复杂度为`O(n)`，空间复杂度为`O(1)`

Floyd 判圈算法还能计算环的长度：当两个指针相遇时，让快指针不动，慢指针继续移动，直到两个指针再次相遇，即可得到长度
如何确定环的起点：假设相遇点是A，在链表起点处添加一个慢指针，与在A点的慢指针一起移动，当两个慢指针相遇时，即为链表的起点。

| 题目 | 解题代码 |
| ----- | ---------- |
| [141.环形链表](https://leetcode-cn.com/problems/linked-list-cycle/) | [Swift代码](141环形链表/Solution.swift) |

## 判断两条链表是否相交
判断两条链表是否相交，即为求两条链表是否在某个节点后重合。

考虑构建两个节点指针 A​ , B 分别指向两链表头节点 headA , headB ，做如下操作：
1. 指针 A 先遍历完链表 headA ，再开始遍历链表 headB
2. 指针 B 先遍历完链表 headB ，再开始遍历链表 headA
两个指针会在某一个节点重合或同时为 nil（两条链表无交集，最终指针去到另一条链表的终点），返回该节点或 nil

| 题目 | 解题代码 |
| ----- | ---------- |
| [160.相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/) | [Swift代码](160相交链表/Solution.swift) |

